<?php

/**
 * ProcessWire Modules Migrator
 * by Adrian Jones
 *
 * Allows automated migration of modules and the config settings.
 *
 * ProcessWire 2.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

ini_set('max_execution_time', 300); //300 seconds = 5 minutes

class ProcessModulesMigrator extends Process implements Module {

    /**
     * getModuleInfo is a module required by all modules to tell ProcessWire about them
     *
     * @return array
     *
     */
    public static function getModuleInfo() {
        return array(
            'title' => 'Modules Migrator',
            'version' => 1,
            'summary' => 'Automatically migrate modules and their settings from one PW installation to another.',
            'singular' => true,
            'autoload' => false,
            'icon'     => 'exchange',
            'nav' => array(
              array(
                'url' => 'export/',
                'label' => 'Export',
                'icon' => 'arrow-right',
              ),
              array(
                'url' => 'import/',
                'label' => 'Import',
                'icon' => 'arrow-left'
              ),
              array(
                'url' => 'restore/',
                'label' => 'Restore',
                'icon' => 'reply'
              )
            )
        );
    }

    /**
     * Name used for the page created in the admin
     *
     */
    const adminPageName = 'modules_migrator';

    protected $data = array();
    protected $moduleFiles = array();
    protected $selectedModules = array();
    protected $migratedModuleClassNames = array();
    protected $importedModuleClassNames = array();
    protected $zipFilename = '';


    /**
     * Initialize the module
     *
     */
    public function init() {
        parent::init();
    }

    /**
     * Executed when root url for module is accessed
     *
     */
    public function ___execute() {

        $form = $this->buildForm1();
        if($this->input->post->submit) {
            if($this->processForm1($form) || $this->processExportForm2($form) || $this->processImportForm2($form)) $this->session->redirect('./'.$this->session->type.'/');
        }
        return $form->render();
    }

    /**
     * Executed when ./export/ url for module is accessed
     *
     */
    public function ___executeExport() {

        $form = $this->buildExportForm2();
        if($this->input->post->submit) {
            return $this->processExportForm2($form);
        } else {
            //$form = $this->buildExportForm2();
            return $form->render();
        }
    }


    /**
     * Executed when ./import/ url for module is accessed
     *
     */
    public function ___executeImport() {

        $form = $this->buildImportForm2();

        if($this->input->post->submit) {
            return $this->processImportForm2($form);
        } else {
            return $form->render();
        }

    }


    /**
     * Executed when ./restore/ url for module is accessed
     *
     */
    public function ___executeRestore() {

        $form = $this->buildRestoreForm2();

        if($this->input->post->submit) {
            return $this->processRestoreForm2($form);
        } else {
            return $form->render();
        }

    }




/**
     * Build the "Step 1" form
     *
     */
    protected function buildForm1() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 1: Export, Import, or Restore";

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'type';
        $f->label = 'Export, Import, or Restore';
        $f->required = true;
        $f->addOption('');
        $f->addOption('export', 'Export');
        $f->addOption('import', 'Import');
        if(class_exists('WireDatabaseBackup')){ //not present in older version of PW - prior to Aug 19, 2014 (approx 2.4.13)
            $f->addOption('restore', 'Restore');
        }
        if($this->session->type) $f->attr('value', $this->session->type);
        $form->add($f);

        $this->addSubmit($form, 'Continue to Step 2');

        return $form;
    }



    /**
     * Process the "Step 1" form and populate session variables with the results
     *
     */
    protected function processForm1(InputfieldForm $form) {

        $form->processInput($this->input->post);
        if(count($form->getErrors())) return false;

        $this->recursiveDelete($this->page->filesManager()->path(), false); //cleanup anything left in the Migrator assets/files directory from previous failed import

        $type = $form->get('type')->value;

        if(!$type) {
            $this->error("Missing required Export/Import/Restore action type");
            return false;
        }

        $this->session->type = $type;
        return true;
    }




    /**
     * Build the "Export Step 2" form
     *
     */
    protected function buildExportForm2() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Choose Modules to Export";

        $f = $this->modules->get("InputfieldAsmSelect");
        $f->name = 'selectedModules';
        $f->label = 'Selected Modules';
        $f->required = true;
        $f->description = "The modules you want to export.";
        $f->setAsmSelectOption('sortable', false);
        foreach($this->modules as $module){
            //$moduleInfo = wire('modules')->getModuleInfoVerbose($module->className());
            // don't show core modules
            //if($moduleInfo['core']) continue; //exclude core modules - this wasn't working. It seems that some modules don't have a "name", hence the use of className below.
            $filename = $this->config->urls->{$module->className()};
            if(preg_match('%^\/wire\/%Uis', $filename) || !$this->modules->isInstalled($module)) continue;
            $f->addOption($module->className(), $module->className());
            $f->attr('value', $module->className());
        }
        $form->add($f);

        $this->addSubmit($form, 'Export');

        return $form;
    }

    /**
     * Process the "Step 2" form and populate session variables with the results
     *
     */
    protected function processExportForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);

        $this->session->selectedModules = $form->get('selectedModules')->value;

        $this->session->jsonFilename = $this->page->filesManager()->path() . 'data.json';

        //write json file to assets folder and add it to the zip download
        file_put_contents($this->session->jsonFilename, $this->pagesToJSON($this->session->selectedModules));
        $allfiles = array($this->session->jsonFilename);
        $this->create_zip($allfiles, $this->page->filesManager()->path().'modules.zip', 'json');
        unlink($this->session->jsonFilename);

        //download the zip to the users
        $zipFilename = $this->page->filesManager()->path().'modules.zip';
        if (file_exists($zipFilename)) {
            header('Content-Description: File Transfer');
            header('Content-Type: application/zip');
            header('Content-Disposition: attachment; filename='.basename($zipFilename));
            header('Expires: 0');
            header('Cache-Control: must-revalidate');
            header('Pragma: public');
            header('Content-Length: ' . filesize($zipFilename));
            ob_clean();
            flush();
            readfile($zipFilename);
            unlink($zipFilename);

        }


    }

    /**
     * Build the "Import Step 2" form to import the json file
     *
     */
    protected function buildImportForm2() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Import";

        if(class_exists('WireDatabaseBackup')){ //not present in older version of PW - prior to Aug 19, 2014 (approx 2.4.13)
            $f = $this->modules->get("InputfieldCheckbox");
            $f->name = 'create_backup';
            $f->label = 'Backup existing database and modules directory';
            $f->description = "Determines whether to backup the existing database and modules directory before importing the new content. Highly Recommended!";
            if($this->session->create_backup) $f->attr('value', $this->session->create_backup);
            $f->attr('checked', $this->session->create_backup == '1' ? 'checked' : '' );
            $form->add($f);
        }

        $f = $this->modules->get("InputfieldFile");
        $f->name = 'zip_file';
        $f->label = 'Zip File Upload';
        $f->extensions = 'zip';
        $f->maxFiles = 1;
        $f->descriptionRows = 0;
        $f->overwrite = true;
        $form->add($f);

        $f = $this->modules->get("InputfieldCheckbox");
        $f->name = 'module_settings';
        $f->label = 'Import Module Settings';
        $f->description = "Determines whether to import the module settings from the source PW install.";
        if($this->session->module_settings) $f->attr('value', $this->session->module_settings);
        $f->attr('checked', $this->session->module_settings == '1' ? 'checked' : '' );
        $form->add($f);

        $f = $this->modules->get("InputfieldCheckbox");
        $f->name = 'choose_modules';
        $f->label = 'Choose Modules to Install';
        $f->description = "If checked you will get another step where you can choose exactly which modules you want to import.";
        $f->attr('checked', $this->session->choose_modules == '1' ? 'checked' : '' );
        $f->collapsed = $f->attr('checked') ? Inputfield::collapsedNo : Inputfield::collapsedYes;
        $form->add($f);


        $this->addSubmit($form, 'Upload and Install Modules');

        return $form;
    }



    /**
     * Build the "Restore Step 2" form to restore database backup
     *
     */
    protected function buildRestoreForm2() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Restore";

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'restore_directory';
        $f->label = 'Backup to Restore';
        $f->required = true;
        foreach($iterator = new RecursiveDirectoryIterator($this->config->paths->assets.'modulesmigratorbackups/', RecursiveDirectoryIterator::SKIP_DOTS) as $item){
            if ($item->isDir()) {

                if(strpos($iterator->getSubPathName(),'_') !== false){
                    //convert dir name to friendly date / time format for restore select dropdown
                    $optionLabel = strstr($iterator->getSubPathName(), '_', true) . " " . str_replace("-", ":", str_replace("_", "", strstr($iterator->getSubPathName(), '_')));
                }
                else{
                    $optionLabel = $iterator->getSubPathName(); // just for anyone who installed the module before the date format changed
                }
                $f->addOption($iterator->getSubPathName(), $optionLabel);
            }
            /*else {
                $f->addOption($iterator->getSubPathName(), $iterator->getSubPathName());
            }*/
        }
        if($this->session->restore_directory) $f->attr('value', $this->session->restore_directory);
        $form->add($f);

        $this->addSubmit($form, 'Restore');

        return $form;
    }



    /**
     * Build the "Import Step 3" form to determine what pages/fields get imported
     *
     */
    protected function buildImportForm3($data) {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 3: Edit Modules to be Imported";


        $f = $this->modules->get("InputfieldAsmSelect");
        $f->name = 'import_modules';
        $f->label = 'Import Modules';
        $f->required = true;

        foreach($data->modules as $module){
            foreach($module as $module_name => $data){
                $f->addOption($module_name, $module_name);
                $f->attr('value', $module_name);
            }
        }

        $f->description = "By default, all modules in the import are selected. Remove any modules that you don't want to import.";
        $f->setAsmSelectOption('sortable', false);
        $form->add($f);


        //these hidden fields are a bit of a hack to prevent field required notices when processing this form because we are using the same code to process Input Form2 and Form3 and session variables are being lost somewhere
        $f = $this->modules->get("InputfieldHidden");
        $f->name = 'create_backup';
        if($this->session->create_backup) $f->attr('value', $this->session->create_backup);
        $form->add($f);

        $f = $this->modules->get("InputfieldHidden");
        $f->name = 'module_settings';
        if($this->session->module_settings) $f->attr('value', $this->session->module_settings);
        $form->add($f);

        $this->addSubmit($form, 'Install Modules');

        return $form;
    }


    /**
     * Process the "Import Step 2" form and upload the zip/json file
     *
     */
    protected function processImportForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);
        //$errors = $form->getErrors(true); used to delete automatic field errors since we want to provide custom ones
        if(count($form->getErrors())) return false;

        if($this->input->post){
            $this->session->import_modules = isset($this->input->post->import_modules) ? $this->input->post->import_modules : '';
            $this->session->module_settings = $form->get('module_settings')->value;
            $this->session->create_backup = $form->get('create_backup')->value;
            if(isset($form->get('jsonFilename')->value)) $this->session->jsonFilename = $form->get('jsonFilename')->value;
        }

        if($this->session->create_backup == 1){

            $backupDir = $this->config->paths->assets.'modulesmigratorbackups/'.date('Y-m-d_H-i-s');

            if (!file_exists($this->config->paths->assets.'modulesmigratorbackups/')) mkdir($this->config->paths->assets.'modulesmigratorbackups/');
            if (!file_exists($backupDir)) mkdir($backupDir);

            $backup = new WireDatabaseBackup($backupDir.'/');
            $backup->setDatabase($this->database);
            $backup->setDatabaseConfig($this->config);

            $file = $backup->backup(array('filename' => 'modulesmigratorbackup.sql'));

            wireCopy($this->config->paths->siteModules, $backupDir . '/', true);

        }


        //for submission of form either without Edit Imported Content, or the first submission to get the modules from the JSON file
        if(!isset($form->get('import_modules')->value) || $form->get('import_modules')->value==''){
            if($form->get('zip_file')->value != ''){
                $zipFile = $form->get('zip_file')->value;
                $this->session->zipFile = $zipFile->first();
                $this->session->zipFile->rename("data.zip");
                $this->session->zipFilename = $this->session->zipFile->filename;
            }

            $this->session->migratorFilesDir = $this->page->filesManager()->path() . 'migratorfiles';
            $this->session->jsonFilename = $this->session->migratorFilesDir . '/data.json';

            if($this->session->zipFilename!=''){
                // extract uploaded zip to destination PW installation
                $zip = new ZipArchive;
                if($zip->open($this->session->zipFilename) === TRUE) {
                    if (!file_exists($this->session->migratorFilesDir)) mkdir($this->session->migratorFilesDir);
                    $zip->extractTo($this->session->migratorFilesDir);
                    $zip->close();
                    unlink($this->session->zipFilename);

                    // set paths for moving files into the destination PW site's modules folder
                    $srcDir = $this->session->migratorFilesDir;
                    $destDir = $this->config->paths->siteModules.'/';

                    // check write permissions on modules directory and fail with friendly error
                    if(file_exists($srcDir) && !is_writable($destDir)){
                        if($this->session->migratorFilesDir && file_exists($this->session->migratorFilesDir)) $this->recursiveDelete($this->session->migratorFilesDir);
                        $this->error("The modules directory is not writeable. Please change permissions and try again.");
                        $form->get('zip_file')->value = '';
                        return $form->render();
                    }

                    //move module files into the modules directory
                    if (file_exists($srcDir) && is_dir($srcDir) && $handle = opendir($srcDir)) {
                        $i=0;
                        foreach($iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($srcDir, RecursiveDirectoryIterator::SKIP_DOTS), RecursiveIteratorIterator::SELF_FIRST) as $item){
                            if(pathinfo($item, PATHINFO_BASENAME) == 'data.json') continue;
                            $modulePath = str_replace($this->session->migratorFilesDir . '/', '', $item);
                            $moduleName = strpos($modulePath,'/') !== false ? strstr($modulePath, '/', true) : $modulePath;
                            if($this->modules->isInstalled($moduleName)) continue; //if already installed then skip
                            if(is_array($this->session->import_modules) && !in_array($moduleName, $this->session->import_modules)) continue; //if not in the list of selected modules to be imported then skip
                            if ($item->isDir()) {
                                if(!file_exists($destDir . $iterator->getSubPathName())){
                                    mkdir($destDir . str_replace("//", "/", $iterator->getSubPathName()));
                                }
                            }
                            else {
                                copy($item, $destDir . str_replace("//", "/", $iterator->getSubPathName()));
                            }
                            $i++;
                        }
                    }
                }
            }
            elseif(file_exists($this->session->migratorFilesDir)){
                //no need to do anything since the directory of files already exists
                //this would be the case when "Choose Modules to Install" was selected.
            }
            else{
                $this->error("Missing required ZIP or JSON Source");
                if($this->session->migratorFilesDir && file_exists($this->session->migratorFilesDir)) $this->recursiveDelete($this->session->migratorFilesDir);
                return $form->render();

                if (!file_exists($this->session->migratorFilesDir)) mkdir($this->session->migratorFilesDir);
                file_put_contents($this->session->jsonFilename, $json);
                //exit;

            }

            //populate $fp with data from json file written to the server
            $fp = file_get_contents($this->session->jsonFilename);


            //if no data source provided, return an error. This check probably isn't necessary because of the ones above.
            if(empty($fp)){

                $this->error("Missing required ZIP or JSON Source");
                if($this->session->migratorFilesDir && file_exists($this->session->migratorFilesDir)) $this->recursiveDelete($this->session->migratorFilesDir);
                //$this->session->redirect('./'.$this->session->type);
                return $form->render();
            }

            //populate $data with json string of all the content to be created
            $data = json_decode($fp);

        }



        //if selected, redirect to form to allow user to determine which modules get installed
        if($this->input->post->choose_modules=='1'){
            $form = $this->buildImportForm3($data);
            return $form->render();
        }


        //print_r($this->session->import_modules);exit;

        foreach($data->modules as $modules){
            foreach($modules as $module_name => $data){
                if(is_array($this->session->import_modules) && !in_array($module_name, $this->session->import_modules)) continue; //if not in the list of selected modules to be imported then skip
                //$this->modules->get($module_name);
                if(!$this->modules->isInstalled($module_name)){
                    $info = $this->modules->getModuleInfoVerbose($module_name);
                    if(count($info['requires'])==0) {
                        //$requires = $this->modules->getRequiresForInstall($module_name); don't know why this and also isInstallable($module_name, true) wasn't working
                        //if(count($requires)) continue;
                        $this->modules->getInstall($module_name);
                        if(!in_array($module_name, $this->migratedModuleClassNames)) $this->migratedModuleClassNames[] = $module_name;
                        if($this->session->module_settings == 1) $this->modules->saveModuleConfigData($module_name, $this->objectToArray($data));
                    }
                }
            }
        }




        //remove the extracted folder of all the migrated module files and the json file
        if($this->session->migratorFilesDir && file_exists($this->session->migratorFilesDir)) $this->recursiveDelete($this->session->migratorFilesDir);

        return $this->processImportForm2Markup();
    }


    public function objectToArray($d) {
        if (is_object($d)) {
            // Gets the properties of the given object
            // with get_object_vars function
            $d = get_object_vars($d);
        }

        if (is_array($d)) {
            return array_map($this->objectToArray, $d);
        }
        else {
            // Return array
            return $d;
        }
    }


    /**
     * Process the "Restore Step 2" form and restore the database backup file
     *
     */
    protected function processRestoreForm2(InputfieldForm $form) {

        $backup = new WireDatabaseBackup($this->config->paths->assets.'modulesmigratorbackups/' . $this->input->post->restore_directory . '/');
        $backup->setDatabase($this->database);
        $backup->setDatabaseConfig($this->config);

        $success = $backup->restore($this->config->paths->assets.'modulesmigratorbackups/' . $this->input->post->restore_directory . '/modulesmigratorbackup.sql');
        if($success) $this->message("Database successfully restored.");
        else $this->error("Sorry, there was a problem and the database could not be restored.");

        $this->recursiveDelete($this->config->paths->siteModules, false); //clean up modules folder so it will only contain those files from the backup

        if(wireCopy($this->config->paths->assets.'modulesmigratorbackups/' . $this->input->post->restore_directory . '/', $this->config->paths->siteModules, true)){
            $this->message("Modules directory successfully restored.");
        }
        else{
            $this->error("Sorry, there was a problem and the modules directory could not be restored.");
        }

        unlink($this->config->paths->siteModules . 'modulesmigratorbackup.sql');

    }



    /**
     * Push all modules to the pageToArray function and then JSON encode
     *
     */
    protected function pagesToJSON($items) {

        $a = array();
        $modules_array = array();

        $i=0;
        foreach($items as $item) {

            if(!in_array($item, $modules_array)){
                $a['modules'][] = $this->pageToArray($item);
                $modules_array[] = $item;
                $moduleInfo = wire('modules')->getModuleInfoVerbose($item);

                $modulePath = str_replace($this->config->paths->siteModules, '', $moduleInfo['file']);
                $moduleRoot = strpos($modulePath,'/') !== false ? strstr($modulePath, '/', true) : $moduleInfo['file'];

                $this->moduleFiles[] = $moduleRoot;
            }

            $i++;

        }


        //Create zip of modules
        $allfiles = array();
        $i=0;
        foreach($this->moduleFiles as $modulepath){
            if(is_dir($this->config->paths->siteModules . $modulepath)){
                $dir = new DirectoryIterator($this->config->paths->siteModules . $modulepath);
                foreach($dir as $file) {
                    if($file->isDir() || $file->isDot()) continue;
                    $allfiles[$i]['newpath'] = $modulepath . '/' . $file->getBasename();
                    $allfiles[$i]['currentpath'] = $file->getPathname();
                    $i++;
                }
            }
            else{
                $allfiles[$i]['newpath'] = pathinfo($modulepath, PATHINFO_BASENAME);
                $allfiles[$i]['currentpath'] = $modulepath;
                $i++;
            }

        }

        //print_r($allfiles);exit;

        $this->create_zip($allfiles,$this->page->filesManager()->path().'modules.zip', 'files');

        return json_encode($a);
    }


    /**
     * Prepare arrays to convert to JSON
     *
     */
    protected function pageToArray($module) {
        $data[$module] = wire('modules')->getModuleConfigData($module);
        return $data;
    }




    /**
     * Provide the completion output markup for processImportForm2
     *
     */
    protected function processImportForm2Markup() {
        $out = '';
        if(count($this->migratedModuleClassNames)>0){
            $out .= "<p><strong>The following modules were imported and installed.</strong></p><p>";
            foreach($this->migratedModuleClassNames as $moduleClassName)
                if(strpos($moduleClassName,'/') === false && !in_array($moduleClassName, $this->importedModuleClassNames)){
                    $this->importedModuleClassNames[] = $moduleClassName;
                    $out .= str_replace('.module', '', $moduleClassName).'<br />';
                }
        }

        $out .= "<p><a href='../import/'>Import more modules</a></p>";

        return $out;
    }



    /**
     * Add a submit button, moved to a function so we don't have to do this several times
     *
     */
    protected function addSubmit(InputfieldForm $form, $value = 'Submit') {
        $f = $this->modules->get("InputfieldSubmit");
        $f->name = 'submit';
        $f->value = $value;
        $form->add($f);
    }


    /**
     * Create zip archive of attached modules for migration
     *
     */
    function create_zip($files = array(), $destination = '', $filetype, $overwrite = false) {
        //if the zip file already exists and overwrite is false, return false
        //if(file_exists($destination) && !$overwrite) return false;
        $valid_files = array();
        if(is_array($files)) {
            foreach($files as $file) {
                //removed the check for now due to @NooseLadder's windows/xampp path issues with file_exists
                //if(file_exists($file['currentpath']) || file_exists($file[0])) $valid_files[] = $file;
                $valid_files[] = $file;
            }
        }
        if(count($valid_files)) {
            //create the archive
            $zip = new ZipArchive();
            if($zip->open($destination, $overwrite ? ZIPARCHIVE::OVERWRITE : ZIPARCHIVE::CREATE) !== true) return false;
            //add the files
            if($filetype == 'files'){
                foreach($valid_files as $path => $file) {
                    $zip->addFile($file['currentpath'],$file['newpath']);
                }
            }
            elseif($filetype == 'json'){
                foreach($valid_files as $file) {
                    $zip->addFile($file, pathinfo($file, PATHINFO_BASENAME));
                }
            }
            //echo 'The zip archive contains ',$zip->numFiles,' files with a status of ',$zip->status;
            $zip->close();

            //check to make sure the file exists
            return file_exists($destination);
        }
        else{
            return false;
        }
    }


    /**
     * Function to recursively delete an entire folder
     *
     */
    public function recursiveDelete($dirPath, $deleteParent = true){
        foreach(new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dirPath, FilesystemIterator::SKIP_DOTS), RecursiveIteratorIterator::CHILD_FIRST) as $path) {
            $path->isFile() ? unlink($path->getPathname()) : rmdir($path->getPathname());
        }
        if($deleteParent) rmdir($dirPath);
    }



    /**
     * Install the module and create the page where it lives
     *
     */
    public function ___install() {

        if(ProcessWire::versionMajor == 2 && ProcessWire::versionMinor < 4) {
            throw new WireException("This module requires ProcessWire 2.4 or newer");
        }

        $wp = $this->getInstalledPage();
        $this->message("Installed to {$wp->path}");
        if($wp->parent->name == 'setup') $this->message("Click to your 'Setup' page to start using Modules Migrator");
    }

    /**
     * Return the page that this Process is installed on
     *
     */
    protected function getInstalledPage() {

        $admin = $this->pages->get($this->config->adminRootPageID);
        $parent = $admin->child("name=setup");
        if(!$parent->id) $parent = $admin;
        $wp = $parent->child("name=" . self::adminPageName);

        if(!$wp->id) {
            $wp = new Page();
            $wp->parent = $parent;
            $wp->template = $this->templates->get('admin');
            $wp->name = self::adminPageName;
            $wp->title = "Modules Migrator";
            $wp->process = $this;
            $wp->sort = $parent->numChildren;
            $wp->save();
        }

        return $wp;
    }

    /**
     * Uninstall the module
     *
     */
    public function ___uninstall() {
        $wp = $this->getInstalledPage();
        if($wp->id) {
            $this->message("Removed {$wp->path}");
            $this->pages->delete($wp);
        }
    }

}
