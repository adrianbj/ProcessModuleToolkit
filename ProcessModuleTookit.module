<?php

/**
 * ProcessWire Module Toolkit
 * by Adrian Jones
 *
 * Automated batch migration, installation and updating of modules and their config settings.
 *
 * ProcessWire 2.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

ini_set('max_execution_time', 300); //300 seconds = 5 minutes

class ProcessModuleTookit extends Process implements Module {

    /**
     * getModuleInfo is a module required by all modules to tell ProcessWire about them
     *
     * @return array
     *
     */
    public static function getModuleInfo() {
        $settings = array(
            'title' => 'Module Toolkit',
            'version' => 15,
            'summary' => 'Automated batch migration, installation and updating of modules and their config settings.',
            'author' => 'Adrian Jones',
            'singular' => true,
            'icon' => 'plug',
            'nav' => array(
                array(
                    'url' => 'install/',
                    'label' => 'Install',
                    'icon' => 'sign-in'
                ),
                array(
                    'url' => 'export/',
                    'label' => 'Export',
                    'icon' => 'upload',
                )
            ),
            'autoload' => function() {
                if(wire('page')->process == 'ProcessWireUpgrade') return true; //only autoload on the ProcessWireUpgrade page
                    else return false;
            }
        );

        $settings['nav'][] = array(
            'url' => 'upgrade/',
            'label' => 'Upgrade',
            'icon' => 'refresh'
        );

        $settings['nav'][] = array(
            'url' => 'cleanup/',
            'label' => 'Upgrade Cleanup',
            'icon' => 'eraser'
        );


        if((class_exists('\ProcessWire\WireDatabaseBackup') || class_exists('WireDatabaseBackup')) && file_exists(wire('config')->paths->assets.'moduletoolkitbackups/')) { // not present in older version of PW - prior to Aug 19, 2014 (approx 2.4.13)
            $settings['nav'][] = array(
                'url' => 'restore/',
                'label' => 'Restore',
                'icon' => 'reply'
            );
        }

        return $settings;
    }

    /**
     * Name used for the page created in the admin
     *
     */
    const adminPageName = 'module_toolkit';

    protected $data = array();
    protected $moduleFiles = array();
    protected $selectedModules = array();
    protected $installedModuleClassNames = array();
    protected $installFailedModuleClassNames = array();
    protected $upgradedModuleClassNames = array();
    protected $zipFilename = '';
    protected $uninstallableCategories = array(
        'language-pack',
        'site-profile',
    );


    /**
     * Initialize the module
     *
     */
    public function init() {
        parent::init();
        $this->addHookAfter('Page::render', $this, 'renderHook');
    }


    public function renderHook($event) {
        $page = $event->object;
        if($page->process != 'ProcessWireUpgrade') return; // shouldn't be necessary given autoload condition above

        $event->return = str_replace('<table id', '<p><a href="../module_toolkit/upgrade/"><button type="button" class="ui-button ui-state-default"><span class="ui-button-text"><i class="fa fa-refresh"></i> Batch Upgrade Modules</span></button></a></p><table id', $event->return);
    }


    /**
     * Executed when root url for module is accessed
     *
     */
    public function ___execute() {

        if(method_exists($this->modules, 'resetCache')) {
            $this->modules->resetCache();
        }

        $form = $this->buildForm1();
        if($this->input->post->submit) {
            if($this->processForm1($form) || $this->processExportForm2($form) || $this->processInstallForm2($form)) $this->session->redirect('./'.$this->session->type.'/');
        }
        return $form->render();
    }

    /**
     * Executed when ./export/ url for module is accessed
     *
     */
    public function ___executeExport() {

        $form = $this->buildExportForm2();
        if($this->input->post->submit) {
            return $this->processExportForm2($form);
        } else {
            //$form = $this->buildExportForm2();
            return $form->render();
        }
    }


    /**
     * Executed when ./install/ url for module is accessed
     *
     */
    public function ___executeInstall() {

        $form = $this->buildInstallForm2();

        if($this->input->post->submit) {
            return $this->processInstallForm2($form);
        } else {
            return $form->render();
        }

    }


    /**
     * Executed when ./restore/ url for module is accessed
     *
     */
    public function ___executeRestore() {

        $form = $this->buildRestoreForm2();

        if($this->input->post->submit) {
            return $this->processRestoreForm2($form);
        } else {
            return $form->render();
        }

    }


    /**
     * Executed when ./upgrade/ url for module is accessed
     *
     */
    public function ___executeUpgrade() {

        $form = $this->buildUpgradeForm2();

        if($this->input->post->submit) {
            return $this->processUpgradeForm2($form);
        } else {
            return $form->render();
        }

    }


    /**
     * Executed when ./cleanup/ url for module is accessed
     *
     */
    public function ___executeCleanup() {

        $form = $this->buildCleanupForm2();

        if($this->input->post->submit) {
            return $this->processCleanupForm2($form);
        } else {
            return $form->render();
        }

    }




/**
     * Build the "Step 1" form
     *
     */
    protected function buildForm1() {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = 'Step 1: Choose Action';

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'type';
        $f->label = 'Choose Action';
        $f->required = true;
        $f->addOption('install', 'Install');
        $f->addOption('export', 'Export');
        $f->addOption('upgrade', 'Upgrade');
        $f->addOption('cleanup', 'Upgrade Cleanup');
        if((class_exists('\ProcessWire\WireDatabaseBackup') || class_exists('WireDatabaseBackup')) && file_exists(wire('config')->paths->assets.'moduletoolkitbackups/')) { // not present in older version of PW - prior to Aug 19, 2014 (approx 2.4.13)
            $f->addOption('restore', 'Restore');
        }
        if($this->session->type) $f->attr('value', $this->session->type);
        $form->add($f);

        $this->addSubmit($form, 'Continue to Step 2');

        return $form;
    }



    /**
     * Process the "Step 1" form and populate session variables with the results
     *
     */
    protected function processForm1(InputfieldForm $form) {

        $form->processInput($this->input->post);
        if(count($form->getErrors())) return false;

        $this->recursiveDelete($this->page->filesManager()->path(), false); //cleanup anything left in the Toolkit assets/files directory from previous failed install

        $type = $form->get('type')->value;

        if(!$type) {
            $this->error("Missing required Export/Install/Restore action type");
            return false;
        }

        $this->session->type = $type;
        return true;
    }




    /**
     * Build the "Export Step 2" form
     *
     */
    protected function buildExportForm2() {

        $this->recursiveDelete($this->page->filesManager()->path(), false); //cleanup anything left in the Toolkit assets/files directory from previous failed install

        if(method_exists($this->modules, 'resetCache')) {
            $this->modules->resetCache();
        }

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Choose Modules to Export";

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'save_or_copy';
        $f->label = 'Output Format';
        $f->description = "Save zip file to your computer or display a Text list or JSON code so you can copy and then paste into new site.\nNB The \"Copy\" options will not work for migrating modules that are not in the ProcessWire modules directory.";
        $f->notes = "NB Even if you choose an option with \"Settings\", you can choose to not configure these during install on the new ProcessWire site.";
        $f->required = true;
        $f->addOption('save', 'Save with Settings (Zip)');
        $f->addOption('copy_list', 'Copy List (Text)');
        $f->addOption('copy_w_settings', 'Copy with Settings (JSON)');
        if($this->session->save_or_copy) $f->attr('value', $this->session->save_or_copy);
        $form->add($f);

        $f = $this->modules->get("InputfieldCheckboxes");
        $f->name = 'selectedModules';
        $f->label = 'Selected Modules';
        $f->required = true;
        $f->description = "Select the modules you want to export.";

        $parentModules = array();

        foreach($this->modules as $module){

            $moduleInfo = wire('modules')->getModuleInfoVerbose($module->className());
            //error_log(print_r($moduleInfo,true));
            // don't show core modules
            //if($moduleInfo['core']) continue; //exclude core modules - this wasn't working. It seems that some modules don't have a "name", hence the use of className below.
            $filename = $this->config->urls->{$module->className()};
            if(preg_match('%^\/wire\/%Uis', $filename) || !wire('modules')->isInstalled($module)) continue;

            $moduleName = $module->className();

            $dependents = $this->modules->getRequiredBy($moduleName, true);
            $requirements = $this->modules->getRequires($moduleName, false, true);
            $installs = $moduleInfo['installs'];
            $dependentsStr = '';
            $requirementsStr = '';
            $installsStr = '';
            foreach($dependents as $name) $dependentsStr .= ($dependentsStr ? ', ' : '') . $name;
            foreach($requirements as $name) {
                if(preg_match('/^([^<>!=]+)([<>!=]+.*)$/', $name, $matches)) {
                    $name = $matches[1];
                    $extra = $matches[2];
                } else $extra = '';
                if($name == 'PHP' || $name == 'ProcessWire') {
                    //don't want to show these requirements
                } else {
                    //echo dirname($this->config->urls->$requirementsStr);
                    //echo $name . ':' . basename($filename) . ':'. basename($this->config->urls->$name) . '<br />';
                    //if folder of required module matches the module, then don't display in list
                    //if(basename($this->config->urls->$name) == basename($filename)) continue 2;
                    if(basename($this->config->urls->$name) == basename($filename)) $parentModules[basename($filename)]['settingsOnly'] = 1;
                    $requirementsStr .= ($requirementsStr ? ', ' : '') . "$name$extra";
                }
            }

            $parentModules[$moduleName]['name'] = $moduleName;
            $parentModules[$moduleName]['dependents'] = $dependentsStr;
            $parentModules[$moduleName]['requirements'] = $requirementsStr;
            $parentModules[$moduleName]['installs'] = $installsStr;
            $parentModules[$moduleName]['info'] = wire('modules')->getModuleInfoVerbose($module->className());
            $parentModules[$moduleName]['settingsOnly'] = 0;
        }

        $finalModulesList = $parentModules;

        foreach($parentModules as $m) {
            $moduleInfo = wire('modules')->getModuleInfoVerbose($m['name']);
            $installs = $moduleInfo['installs'];
            foreach($installs as $name) {
                $installsStr .= ($installsStr ? ', ' : '') . $name;
                $finalModulesList[$name]['settingsOnly'] = 1;
            }
        }
        foreach($finalModulesList as $m) {
            if(!isset($m['name'])) continue;
            $f->addOption($m['name'], $m['name'] . ($m['dependents'] ? ' (Required by: ' . $m['dependents'] .')' : '') . ($m['requirements'] ? ' (Requires: ' . $m['requirements'] .')' : '') . ($m['installs'] ? ' (Installs: ' . $m['installs'] .')' : ''));
            $f->attr('disabled', 'disabled');
            $f->attr('value', $m['name']);
        }

        //$f->notes = "Companion modules (those that are requirements of, or are installed by, one of the main modules and included in the module directory) are intentionally not included in this list.";
        $form->add($f);

        $this->addSubmit($form, 'Export');

        return $form;
    }

    /**
     * Process the "Step 2" form and populate session variables with the results
     *
     */
    protected function processExportForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);

        $this->session->save_or_copy = $form->get('save_or_copy')->value;
        $this->session->selectedModules = $form->get('selectedModules')->value;

        if($this->session->save_or_copy == 'copy_list'){
            return '<p><textarea rows="10" style="width:95%">' . $this->modulesToText($this->session->selectedModules) . '</textarea></p><p>Copy this text and use the Install > Paste option to install these modules.</p><p><a href="../export/">Export more modules</a></p>';
        }
        elseif($this->session->save_or_copy == 'copy_w_settings'){
            return '<p><textarea rows="10" style="width:95%">' . $this->modulesToJSON($this->session->selectedModules, false) . '</textarea></p><p>Copy this text and use the Install > Paste option to install and configure these modules.</p><p><a href="../export/">Export more modules</a></p>';
        }
        else{
            $this->session->jsonFilename = $this->page->filesManager()->path() . 'data.json';

            //write json file to assets folder and add it to the zip download
            file_put_contents($this->session->jsonFilename, $this->modulesToJSON($this->session->selectedModules, true));
            $allfiles = array($this->session->jsonFilename);
            $this->create_zip($allfiles, $this->page->filesManager()->path().'modules.zip', 'json');
            unlink($this->session->jsonFilename);

            //download the zip to the users
            $zipFilename = $this->page->filesManager()->path().'modules.zip';
            if (file_exists($zipFilename)) {
                header('Content-Description: File Transfer');
                header('Content-Type: application/zip');
                header('Content-Disposition: attachment; filename='.basename($zipFilename));
                header('Expires: 0');
                header('Cache-Control: must-revalidate');
                header('Pragma: public');
                header('Content-Length: ' . filesize($zipFilename));
                ob_clean();
                flush();
                readfile($zipFilename);
                unlink($zipFilename);
            }
        }
    }

    /**
     * Build the "Install Step 2" form to install the json file
     *
     */
    protected function buildInstallForm2() {

        $this->recursiveDelete($this->page->filesManager()->path(), false); //cleanup anything left in the Toolkit assets/files directory from previous failed install

        if(method_exists($this->modules, 'resetCache')) {
            $this->modules->resetCache();
        }

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Install";

        if(class_exists('\ProcessWire\WireDatabaseBackup') || class_exists('WireDatabaseBackup')) { //not present in older version of PW - prior to Aug 19, 2014 (approx 2.4.13)
            $f = $this->modules->get("InputfieldCheckbox");
            $f->name = 'create_backup';
            $f->label = 'Backup existing database and modules directory';
            $f->description = "Determines whether to backup the existing database and modules directory before installing the new content.";
            if($this->session->create_backup) $f->attr('value', $this->session->create_backup);
            $f->attr('checked', $this->session->create_backup == '1' ? 'checked' : '' );
            $f->collapsed = Inputfield::collapsedBlank;
            $form->add($f);
        }

        $f = $this->modules->get("InputfieldTextarea");
        $f->name = 'modules_list';
        $f->label = 'Text List of Modules to Install';
        $f->description = "Enter one module class name (or URL to zip) per line.";
        $f->notes = "Use this or the JSON or Zip File upload option, not all at once.";
        $f->collapsed = Inputfield::collapsedBlank;
        $form->add($f);

        $f = $this->modules->get("InputfieldTextarea");
        $f->name = 'json_data';
        $f->label = 'JSON of Modules to Install and Configure';
        $f->description = "Paste in JSON content exported from another site using this module.";
        $f->notes = "Use this or the Text List or Zip File upload option, not all at once.";
        $f->collapsed = Inputfield::collapsedBlank;
        $form->add($f);

        $f = $this->modules->get("InputfieldFile");
        $f->name = 'zip_file';
        $f->label = 'Zip File Upload';
        $f->extensions = 'zip';
        $f->maxFiles = 1;
        $f->description = "Select a zip file of modules exported from a different Processwire installation.";
        $f->notes = "Use this or the JSON or Text List option, not all at once.";
        $f->overwrite = true;
        $f->collapsed = Inputfield::collapsedBlank;
        $form->add($f);

        $f = $this->modules->get("InputfieldCheckbox");
        $f->name = 'module_settings';
        $f->label = 'Install Module Settings';
        $f->showIf = "zip_file|json_data!=''";
        $f->description = "Determines whether to install the module settings from the source PW install.";
        if($this->session->module_settings) $f->attr('value', $this->session->module_settings);
        $f->attr('checked', $this->session->module_settings == '1' ? 'checked' : '' );
        $form->add($f);

        /*$f = $this->modules->get("InputfieldCheckbox");
        $f->name = 'live_upgrade';
        $f->label = 'Live Upgrade Modules';
        $f->showIf = "zip_file!=''";
        $f->description = "Automatically upgrade all of the installed modules (if they are in the ProcessWire modules directory) to their latest available versions.";
        if($this->session->live_upgrade) $f->attr('value', $this->session->live_upgrade);
        $f->attr('checked', $this->session->live_upgrade == '1' ? 'checked' : '' );
        $form->add($f);*/

        $f = $this->modules->get("InputfieldCheckbox");
        $f->name = 'choose_modules';
        $f->label = 'Choose Modules to Install';
        $f->showIf = "zip_file|json_data!=''";
        $f->description = "If checked you will get another step where you can choose exactly which modules you want to install.";
        $f->attr('checked', $this->session->choose_modules == '1' ? 'checked' : '' );
        $form->add($f);

        $this->addSubmit($form, 'Install Modules');

        return $form;
    }



    /**
     * Build the "Restore Step 2" form to restore database backup
     *
     */
    protected function buildRestoreForm2() {

        $this->recursiveDelete($this->page->filesManager()->path(), false); //cleanup anything left in the Toolkit assets/files directory from previous failed install

        if(method_exists($this->modules, 'resetCache')) {
            $this->modules->resetCache();
        }

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Restore";

        $f = $this->modules->get("InputfieldSelect");
        $f->name = 'restore_directory';
        $f->label = 'Backup to Restore';
        $f->required = true;
        foreach($iterator = new RecursiveDirectoryIterator($this->config->paths->assets.'moduletoolkitbackups/', RecursiveDirectoryIterator::SKIP_DOTS) as $item){
            if ($item->isDir()) {

                if(strpos($iterator->getSubPathName(),'_') !== false){
                    //convert dir name to friendly date / time format for restore select dropdown
                    $optionLabel = strstr($iterator->getSubPathName(), '_', true) . " " . str_replace("-", ":", str_replace("_", "", strstr($iterator->getSubPathName(), '_')));
                }
                else{
                    $optionLabel = $iterator->getSubPathName(); // just for anyone who installed the module before the date format changed
                }
                $f->addOption($iterator->getSubPathName(), $optionLabel);
            }
            /*else {
                $f->addOption($iterator->getSubPathName(), $iterator->getSubPathName());
            }*/
        }
        if($this->session->restore_directory) $f->attr('value', $this->session->restore_directory);
        $form->add($f);

        $this->addSubmit($form, 'Restore');

        return $form;
    }



    /**
     * Build the "Install Step 3" form to determine what pages/fields get installed
     *
     */
    protected function buildInstallForm3($data) {

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 3: Edit Modules to be Installed";


        $f = $this->modules->get("InputfieldCheckboxes");
        $f->name = 'install_modules';
        $f->label = 'Install Modules';
        $f->required = true;

        foreach($data->modules as $module){
            foreach($module as $module_name => $data_details){
                $f->addOption($module_name, $module_name);
                $f->attr('value', $module_name);
            }
        }

        $f->description = "By default, all available modules are checked. Uncheck any modules that you don't want to install.";
        $form->add($f);


        //these hidden fields are a bit of a hack to prevent field required notices when processing this form because we are using the same code to process Input Form2 and Form3 and session variables are being lost somewhere
        $f = $this->modules->get("InputfieldHidden");
        $f->name = 'create_backup';
        if($this->session->create_backup) $f->attr('value', $this->session->create_backup);
        $form->add($f);

        $f = $this->modules->get("InputfieldHidden");
        $f->name = 'module_settings';
        if($this->session->module_settings) $f->attr('value', $this->session->module_settings);
        $form->add($f);

        $f = $this->modules->get("InputfieldHidden");
        $f->name = 'json_data';
        if($this->session->jsonData) $f->attr('value', $this->session->jsonData);
        $form->add($f);

        /*$f = $this->modules->get("InputfieldHidden");
        $f->name = 'live_upgrade';
        if($this->session->live_upgrade) $f->attr('value', $this->session->live_upgrade);
        $form->add($f);*/

        $this->addSubmit($form, 'Install Modules');

        return $form;
    }


    /**
     * Process the "Install Step 2" form and upload the zip/json file
     *
     */
    protected function processInstallForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);
        //$errors = $form->getErrors(true); used to delete automatic field errors since we want to provide custom ones
        if(count($form->getErrors())) return false;

        if($this->input->post){
            $this->session->install_modules = isset($this->input->post->install_modules) ? $this->input->post->install_modules : array();
            $this->session->module_settings = $form->get('module_settings')->value;
            //$this->session->live_upgrade = $form->get('live_upgrade')->value;
            $this->session->create_backup = $form->get('create_backup')->value;
            if(isset($form->get('jsonFilename')->value)) $this->session->jsonFilename = $form->get('jsonFilename')->value;
        }

        if($this->session->create_backup == 1){
            $this->createBackup();
        }


        if($this->input->post->modules_list != ''){
            $modulesList = $this->input->post->modules_list;
            $this->session->modulesList = $modulesList;

            // array of modules currently not installed but available to install
            $installedModules = $this->getInstallableModules();

            foreach(explode("\n", $this->input->post->modules_list) as $module_name) {
                if(!wire('modules')->isInstalled($module_name)){
                    $info = $this->modules->getModuleInfoVerbose($module_name);
                    if(count($info['requires'])==0) {
                        //$requires = $this->modules->getRequiresForInstall($module_name); don't know why this and also isInstallable($module_name, true) wasn't working
                        //if(count($requires)) continue;
                        error_log('1: '.$module_name);
                        $this->modules->getInstall($module_name);
                        $this->downloadAndInstall($module_name, true);
                    }
                    else {
                        $this->installFailedModuleClassNames[] = $module_name;
                    }
                }
            }

            // now we've downloaded all requested modules, check to see which new ones are available and install
            // this is just for URL and local path zip entries. Other modules should have already been installed with the downloadAndInstall() method
            $newModules = array_diff($this->getInstallableModules(), $installedModules);

            foreach($newModules as $m) {
                if($this->modules->get($m)) {
                    $this->installedModuleClassNames[] = $m;
                }
                else {
                    $this->installFailedModuleClassNames[] = $m;
                }
            }

            if(method_exists($this->modules, 'resetCache')) $this->modules->resetCache();

            return $this->processInstallForm2Markup();
        }


        //for submission of form either without Choose Modules to Install, or the first submission to get the modules from the JSON file
        if(!$this->input->post->install_modules || $this->input->post->install_modules == ''){
            if($form->get('zip_file')->value != ''){
                $zipFile = $form->get('zip_file')->value;
                $this->session->zipFile = $zipFile->first();
                $this->session->zipFile->rename("data.zip");
                $this->session->zipFilename = $this->session->zipFile->filename;
            }

            $this->session->toolkitFilesDir = $this->page->filesManager()->path() . 'toolkitfiles';
            $this->session->jsonFilename = $this->session->toolkitFilesDir . '/data.json';
            if($form->get('json_data')->value != '') {
                $this->session->jsonData = $form->get('json_data')->value;
            }
            else {
                $this->session->remove("jsonData");
            }

            if($this->session->zipFilename!=''){
                // extract uploaded zip to destination PW installation
                $zip = new ZipArchive;
                if($zip->open($this->session->zipFilename) === TRUE) {
                    if (!file_exists($this->session->toolkitFilesDir)) mkdir($this->session->toolkitFilesDir);
                    $zip->extractTo($this->session->toolkitFilesDir);
                    $zip->close();
                    unlink($this->session->zipFilename);

                    // set paths for moving files into the destination PW site's modules folder
                    $srcDir = $this->session->toolkitFilesDir;
                    $destDir = $this->config->paths->siteModules.'/';

                    // check write permissions on modules directory and fail with friendly error
                    if(file_exists($srcDir) && !is_writable($destDir)){
                        if($this->session->toolkitFilesDir && file_exists($this->session->toolkitFilesDir)) $this->recursiveDelete($this->session->toolkitFilesDir);
                        $this->error("The modules directory is not writeable. Please change permissions and try again.");
                        $form->get('zip_file')->value = '';
                        return $form->render();
                    }

                    //move module files into the modules directory
                    if (file_exists($srcDir) && is_dir($srcDir) && $handle = opendir($srcDir)) {
                        $i=0;
                        foreach($iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($srcDir, RecursiveDirectoryIterator::SKIP_DOTS), RecursiveIteratorIterator::SELF_FIRST) as $item){
                            if(pathinfo($item, PATHINFO_BASENAME) == 'data.json') continue;
                            $modulePath = str_replace($this->session->toolkitFilesDir . '/', '', $item);
                            $moduleName = strpos($modulePath,'/') !== false ? strstr($modulePath, '/', true) : $modulePath;
                            if(wire('modules')->isInstalled($moduleName)) continue; //if already installed then skip
                            if(!empty($this->session->install_modules) && !in_array($moduleName, $this->session->install_modules)) continue; //if not in the list of selected modules to be installed then skip
                            if ($item->isDir()) {
                                if(!file_exists($destDir . $iterator->getSubPathName())){
                                    mkdir($destDir . str_replace("//", "/", $iterator->getSubPathName()));
                                }
                            }
                            else {
                                if(is_writable($destDir)) {
                                    copy($item, $destDir . str_replace("//", "/", $iterator->getSubPathName()));
                                }
                                else {
                                    $this->error("Some modules could not be copied due to insufficient file permissions. Make sure your modules directory and all folders/file inside are writeable.");
                                }
                            }
                            $i++;
                        }
                    }
                }
            }
            elseif(file_exists($this->session->toolkitFilesDir)){
                //no need to do anything since the directory of files already exists
                //this would be the case when "Choose Modules to Install" was selected.
            }
            elseif($this->session->jsonData) {
                $json = $this->session->jsonData;
                if (!file_exists($this->session->toolkitFilesDir)) mkdir($this->session->toolkitFilesDir);
                file_put_contents($this->session->jsonFilename, $json);
            }
            else{
                $this->error("Missing required ZIP or JSON Source");
                if($this->session->toolkitFilesDir && file_exists($this->session->toolkitFilesDir)) $this->recursiveDelete($this->session->toolkitFilesDir);
                return $form->render();
            }

            //populate $fp with data from json file written to the server
            $fp = file_get_contents($this->session->jsonFilename);

            //if no data source provided, return an error. This check probably isn't necessary because of the ones above.
            if(empty($fp)){

                $this->error("Missing required ZIP or JSON Source");
                if($this->session->toolkitFilesDir && file_exists($this->session->toolkitFilesDir)) $this->recursiveDelete($this->session->toolkitFilesDir);
                //$this->session->redirect('./'.$this->session->type);
                return $form->render();
            }

            //populate $data with json string of all the content to be created
            $data = json_decode($fp);

        }


        //if selected, redirect to form to allow user to determine which modules get installed
        if($this->input->post->choose_modules=='1'){
            $form = $this->buildInstallForm3($data);
            return $form->render();
        }

        foreach($data->modules as $modules){
            foreach($modules as $module_name => $data_details){
                if(!empty($this->session->install_modules) && !in_array($module_name, $this->session->install_modules)) continue; //if not in the list of selected modules to be installed then skip
                //$this->modules->get($module_name);
                if(!wire('modules')->isInstalled($module_name)){
                    $info = $this->modules->getModuleInfoVerbose($module_name);
                    //if(count($info['requires'])==0) {
                        //$requires = $this->modules->getRequiresForInstall($module_name); don't know why this and also isInstallable($module_name, true) wasn't working
                        //if(count($requires)) continue;
                        $this->modules->getInstall($module_name);
                        if($this->session->jsonData) $this->downloadAndInstall($module_name, true); // if only json need to download and install before saving config settings
                        if($this->session->module_settings == 1) $this->modules->saveModuleConfigData($module_name, $this->objectToArray($data_details));
                        //if(!$this->session->jsonData && $this->session->live_upgrade == 1) $this->downloadAndInstall($module_name, true);
                    //}
                    $this->installedModuleClassNames[] = $module_name;
                }
            }
        }

        if(method_exists($this->modules, 'resetCache')) {
            $this->modules->resetCache();
        }


        //remove the extracted folder of all the migrated module files and the json file
        if($this->session->toolkitFilesDir && file_exists($this->session->toolkitFilesDir)) $this->recursiveDelete($this->session->toolkitFilesDir);

        return $this->processInstallForm2Markup();
    }



    /**
     * Process the "Upgrade Step 2" form and upgrade all selected modules
     *
     */
    protected function processUpgradeForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);

        if(count($form->getErrors())) return false;

        if($this->input->post){
            $this->session->create_backup = $form->get('create_backup')->value;
            $this->session->upgrade_modules = isset($this->input->post->upgrade_modules) ? $this->input->post->upgrade_modules : '';
        }

        if($this->session->create_backup == 1){
            $this->createBackup();
        }

        foreach($this->modules as $module){
            if(is_array($this->session->upgrade_modules) && !in_array($module->className(), $this->session->upgrade_modules)) continue; //if not in the list of selected modules to be installed then skip
            $this->downloadAndInstall($module->className(), true);
            $this->upgradedModuleClassNames[] = $module->className();
        }

        if(method_exists($this->modules, 'resetCache')) {
            $this->modules->resetCache();
        }

        return $this->processUpgradeForm2Markup();

    }


    /**
     * Process the "Cleanup Step 2" form and delete all selected modules
     *
     */
    protected function processCleanupForm2(InputfieldForm $form) {

        $form->processInput($this->input->post);

        if(count($form->getErrors())) return false;

        if($this->input->post){
            $this->session->upgrade_cleanup = isset($this->input->post->upgrade_cleanup) ? $this->input->post->upgrade_cleanup : '';
        }

        foreach($this->session->upgrade_cleanup as $item){
            if(!file_exists($item)) continue;
            if(!is_dir($item)) {
                unlink ($item);
            }
            else {
                $this->recursiveDelete($item, true);
            }
        }

        return $this->processCleanupForm2Markup();

    }



    public function objectToArray($d) {
        if (is_object($d)) {
            // Gets the properties of the given object
            // with get_object_vars function
            $d = get_object_vars($d);
        }

        if (is_array($d)) {
            return array_map($this->objectToArray, $d);
        }
        else {
            // Return array
            return $d;
        }
    }


    /**
     * Process the "Restore Step 2" form and restore the database backup file
     *
     */
    protected function processRestoreForm2(InputfieldForm $form) {

        $backup = new WireDatabaseBackup($this->config->paths->assets.'moduletoolkitbackups/' . $this->input->post->restore_directory . '/');
        $backup->setDatabase($this->database);
        $backup->setDatabaseConfig($this->config);

        $success = $backup->restore($this->config->paths->assets.'moduletoolkitbackups/' . $this->input->post->restore_directory . '/moduletoolkitbackup.sql');
        if($success) $this->message("Database successfully restored.");
        else $this->error("Sorry, there was a problem and the database could not be restored.");

        $this->recursiveDelete($this->config->paths->siteModules, false); //clean up modules folder so it will only contain those files from the backup

        if(wireCopy($this->config->paths->assets.'moduletoolkitbackups/' . $this->input->post->restore_directory . '/', $this->config->paths->siteModules, true)){
            $this->message("Modules directory successfully restored.");
        }
        else{
            $this->error("Sorry, there was a problem and the modules directory could not be restored.");
        }

        unlink($this->config->paths->siteModules . 'moduletoolkitbackup.sql');

    }



    /**
     * Build the "Install Step 2" form to install the json file
     *
     */
    protected function buildUpgradeForm2() {

        $this->recursiveDelete($this->page->filesManager()->path(), false); //cleanup anything left in the Toolkit assets/files directory from previous failed install

        if(method_exists($this->modules, 'resetCache')) {
            $this->modules->resetCache();
        }

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Upgrade";

        if(class_exists('\ProcessWire\WireDatabaseBackup') || class_exists('WireDatabaseBackup')) { //not present in older version of PW - prior to Aug 19, 2014 (approx 2.4.13)
            $f = $this->modules->get("InputfieldCheckbox");
            $f->name = 'create_backup';
            $f->label = 'Backup existing database and modules directory';
            $f->description = "Determines whether to backup the existing database and modules directory before installing the new content. Highly Recommended!";
            if($this->session->create_backup) $f->attr('value', $this->session->create_backup);
            $f->attr('checked', $this->session->create_backup == '1' ? 'checked' : '' );
            $form->add($f);
        }

        $f = $this->modules->get("InputfieldCheckboxes");
        $f->name = 'upgrade_modules';
        $f->label = 'Upgrade Modules';


        $items = $this->getVersions();
        if(count($items)) {
            $i=0;
            foreach($items as $name => $item) {
                if(empty($item['remote'])) continue; // not in directory
                if($name == 'ProcessWire dev' || $name == 'ProcessWire master') continue;
                if($item['new'] <= 0) continue;
                $f->addOption($name, $item['title'] . ' ('.$name.') - Installed: ' . $item['local'] . ', Remote: ' . $item['remote']);
                $f->attr('value', $name);
                $i++;
            }
        }

        if($i>0) {
            $f->description = "All modules in this list have available upgrades. Uncheck any modules that you don't want to upgrade.";
            $f->notes = "All the selected modules will be upgraded in one step. Please be sure this is what you want to do before clicking the Upgrade button below.";
        }
        else {
            $f->description = "There are no modules that have upgrades available.";
        }

        $form->add($f);


        if($i>0) $this->addSubmit($form, 'Upgrade Selected Modules');

        return $form;
    }


    /**
     * Build the Upgrade Cleanup form
     *
     */
    protected function buildCleanupForm2() {

        $this->recursiveDelete($this->page->filesManager()->path(), false); //cleanup anything left in the Toolkit assets/files directory from previous failed install

        if(method_exists($this->modules, 'resetCache')) {
            $this->modules->resetCache();
        }

        $form = $this->modules->get("InputfieldForm");
        $form->method = 'post';
        $form->description = "Step 2: Upgrade Cleanup";

        $f = $this->modules->get("InputfieldCheckboxes");
        $f->name = 'upgrade_cleanup';
        $f->label = 'Upgrade Cleanup';

        $i=0;
        //site modules
        foreach($iterator = new DirectoryIterator($this->config->paths->siteModules) as $item){
            if($item->isDot() || !$item->isDir()) continue;
            if(substr($item->getFilename(), 0, 1) !== '.') continue;
            $f->addOption($item->getPathname(), $item->getFilename());
            $f->attr('value', $item->getPathname());
            $i++;
        }

        //PW core
        foreach($iterator = new DirectoryIterator($this->config->paths->root) as $item){
            if($item->isDot()) continue;
            if(substr($item->getFilename(), 0, 1) !== '.' || strpos($item->getFilename(), '.git') !== false) continue;
            if(!$item->isDir() && strpos($item->getFilename(), '.htaccess') === false && strpos($item->getFilename(), '.index') === false) continue;
            if(strpos($item->getFilename(), '.htaccess') !== false && strpos($item->getFilename(), '-') === false) continue;
            $f->addOption($item->getPathname(), $item->getFilename());
            $f->attr('value', $item->getPathname());
            $i++;
        }

        if($i>0) {
            $f->description = "All items in this list have backups of old versions that can be deleted. Uncheck any items that you don't want to delete the backups of.";
            $f->notes = "All the selected item backups will be deleted in one step. Please be sure this is what you want to do before clicking the Cleanup button below.";
        }
        else {
            $f->description = "There are no items that have backups that can be deleted.";
        }

        $form->add($f);

        if($i>0) $this->addSubmit($form, 'Cleanup Selected Modules');

        return $form;
    }


    /**
     * Push all modules to the pageToArray function and then JSON encode
     *
     */
    protected function modulesToJSON($items, $zip) {

        $a = array();
        $modules_array = array();

        $i=0;
        foreach($items as $item) {

            if(!in_array($item, $modules_array)){
                $a['modules'][] = $this->pageToArray($item);
                $modules_array[] = $item;
                $moduleInfo = wire('modules')->getModuleInfoVerbose($item);

                $modulePath = str_replace($this->config->paths->siteModules, '', $moduleInfo['file']);
                $moduleRoot = strpos($modulePath,'/') !== false ? strstr($modulePath, '/', true) : $moduleInfo['file'];

                $this->moduleFiles[] = $moduleRoot;
            }

            $i++;

        }

        if($zip) {
            //Create zip of modules
            $allfiles = array();
            $i=0;
            foreach($this->moduleFiles as $modulepath){
                if(is_dir($this->config->paths->siteModules . $modulepath)){
                    $dir = new DirectoryIterator($this->config->paths->siteModules . $modulepath);
                    foreach($dir as $file) {
                        if($file->isDir() || $file->isDot()) continue;
                        $allfiles[$i]['newpath'] = $modulepath . '/' . $file->getBasename();
                        $allfiles[$i]['currentpath'] = $file->getPathname();
                        $i++;
                    }
                }
                else{
                    $allfiles[$i]['newpath'] = pathinfo($modulepath, PATHINFO_BASENAME);
                    $allfiles[$i]['currentpath'] = $modulepath;
                    $i++;
                }
            }

            $this->create_zip($allfiles, $this->page->filesManager()->path().'modules.zip', 'files');

        }

        return json_encode($a);
    }



    /**
     * Prepare arrays to convert to JSON
     *
     */
    protected function pageToArray($module) {
        $data[$module] = wire('modules')->getModuleConfigData($module);
        return $data;
    }



    protected function modulesToText($items) {
        $a = '';
        $modules_array = array();
        $i=0;
        foreach($items as $item) {
            if(!in_array($item, $modules_array)){
                $a .= $item . "\n";
                $modules_array[] = $item;
            }
            $i++;
        }
        return trim($a, "\n");
    }



    /**
     * Provide the completion output markup for processInstallForm2
     *
     */
    protected function processInstallForm2Markup() {
        $out = '';
        if(count($this->installedModuleClassNames)>0){
            $out .= "<p><strong>The following modules were successfully installed:</strong></p><p>";
            foreach(array_unique($this->installedModuleClassNames) as $moduleClassName) {
                $out .= '<a href="'.$this->config->urls->admin.'module/edit?name='.$moduleClassName.'">' . $moduleClassName .'</a><br />';
            }
        }
        else {
            $out .= "<p><strong>No modules were installed.</strong></p>";
        }

        if(count($this->installFailedModuleClassNames)>0){
            $out .= "<p><strong>The following modules failed to install:</strong></p>";
            foreach(array_unique($this->installFailedModuleClassNames) as $moduleClassName) {
                $out .= $moduleClassName .'<br />';
            }
        }

        $out .= "<p><strong><a href='../install/'>Install more modules</a></strong></p>";

        return $out;
    }


    /**
     * Provide the completion output markup for processUpgradeForm2
     *
     */
    protected function processUpgradeForm2Markup() {
        $out = '';
        if(count($this->upgradedModuleClassNames)>0){
            $out .= "<p><strong>The following modules were successfullly upgraded:</strong></p><p>";
            foreach(array_unique($this->upgradedModuleClassNames) as $moduleClassName) {
                $out .= '<a href="'.$this->config->urls->admin.'module/edit?name='.$moduleClassName.'">' . $moduleClassName .'</a><br />';
            }
            $out .= "<p>NB You may need to refresh your modules page to see the updated versions.</p>";
        }

        return $out;
    }


    /**
     * Provide the completion output markup for processUpgradeForm2
     *
     */
    protected function processCleanupForm2Markup() {
        $out = '<p>The following backup items were deleted.</p>';
        foreach($this->session->upgrade_cleanup as $item) {
            $out .= pathinfo($item, PATHINFO_BASENAME) . '<br />';
        }
        return $out;
    }




    /**
     * Add a submit button, moved to a function so we don't have to do this several times
     *
     */
    protected function addSubmit(InputfieldForm $form, $value = 'Submit') {
        $f = $this->modules->get("InputfieldSubmit");
        $f->name = 'submit';
        $f->value = $value;
        $form->add($f);
    }


    /**
     * Create zip archive of attached modules for migration
     *
     */
    function create_zip($files = array(), $destination = '', $filetype, $overwrite = false) {
        //if the zip file already exists and overwrite is false, return false
        //if(file_exists($destination) && !$overwrite) return false;
        $valid_files = array();
        if(is_array($files)) {
            foreach($files as $file) {
                //removed the check for now due to @NooseLadder's windows/xampp path issues with file_exists
                //if(file_exists($file['currentpath']) || file_exists($file[0])) $valid_files[] = $file;
                $valid_files[] = $file;
            }
        }
        if(count($valid_files)) {
            //create the archive
            $zip = new ZipArchive();
            if($zip->open($destination, $overwrite ? ZIPARCHIVE::OVERWRITE : ZIPARCHIVE::CREATE) !== true) return false;
            //add the files
            if($filetype == 'files'){
                foreach($valid_files as $path => $file) {
                    $zip->addFile($file['currentpath'],$file['newpath']);
                }
            }
            elseif($filetype == 'json'){
                foreach($valid_files as $file) {
                    $zip->addFile($file, pathinfo($file, PATHINFO_BASENAME));
                }
            }
            //echo 'The zip archive contains ',$zip->numFiles,' files with a status of ',$zip->status;
            $zip->close();

            //check to make sure the file exists
            return file_exists($destination);
        }
        else{
            return false;
        }
    }


    /**
     * Function to recursively delete an entire folder
     *
     */
    public function recursiveDelete($dirPath, $deleteParent = true){
        foreach(new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dirPath, FilesystemIterator::SKIP_DOTS), RecursiveIteratorIterator::CHILD_FIRST) as $path) {
            if(is_writable($path->getPathname())) {
                $path->isFile() ? unlink($path->getPathname()) : rmdir($path->getPathname());
            }
            else {
                $this->error("Some files could not be deleted due to insufficient file permissions. Make sure your modules directory and all folders/file inside are writeable.");
            }
        }
        if($deleteParent) rmdir($dirPath);
    }



    public function downloadAndInstall($name, $upgrade = false) {

        require_once(wire('config')->paths->modules . 'Process/ProcessModule/ProcessModuleInstall.php');
        if(class_exists('\ProcessWire\ProcessModuleInstall')) {
            $install = new \ProcessWire\ProcessModuleInstall();
        }
        else {
            $install = new ProcessModuleInstall();
        }

        //URL to zip
        if (strpos($name,'//') !== false && strpos($name,'.zip') !== false) {
            $install->downloadModule($name);
        }
        // module class name
        else {
            $name = $this->wire('sanitizer')->name($name);
            $info = self::getModuleInfo();
            $redirectURL = $upgrade ? "./edit?name=$name" : "./";
            $className = $name;
            $url = trim($this->wire('config')->moduleServiceURL, '/') . "/$className/?apikey=" . $this->wire('sanitizer')->name($this->wire('config')->moduleServiceKey);
            $http = new WireHttp();
            $data = $http->get($url);

            if(empty($data)) {
                $this->error($this->_('Error retrieving data from web service URL') . ' - ' . $http->getError());
                return $this->session->redirect($redirectURL);
            }
            $data = json_decode($data, true);
            if(empty($data)) {
                $this->error($this->_('Error decoding JSON from web service'));
                return $this->session->redirect($redirectURL);
            }

            if($data['status'] == 'success') {

                $installable = true;
                foreach($data['categories'] as $category) {
                    if(!in_array($category['name'], $this->uninstallableCategories)) continue;
                    $this->error(sprintf($this->_('Sorry modules of type "%s" are not installable from the admin.'), $category['title']));
                    $installable = false;
                    $this->installFailedModuleClassNames[] = $className;
                }
                if(!$installable) return;

                $installed = wire('modules')->isInstalled($className) ? $this->modules->getModuleInfoVerbose($className) : null;
                $installedVersion = $this->modules->formatVersion($installed['version']);
                if(version_compare($installedVersion, $data['module_version']) < 0) {

                    $destinationDir = $this->wire('config')->paths->siteModules . $className . '/';
                    $completedDir = $install->downloadModule($data['download_url'], $destinationDir);

                    //install the module
                    $this->modules->get($className);

                    if($completedDir) {
                        $this->installedModuleClassNames[] = $className;
                        return;
                    }
                    else {
                        $this->installFailedModuleClassNames[] = $className;
                        return;
                    }

                }

            }
            else{
                $this->installFailedModuleClassNames[] = $className;
            }

        }

    }


    // simplified version of the one in ProcessWireUpgradeCheck module - omits checks for core upgrades
    public function getVersions() {
        $versions = array();
        if($this->config->moduleServiceKey) {
            foreach($this->getModuleVersions(false) as $name => $info) {
                $versions[$name] = $info;
            }
        }
        return $versions;
    }



    // exact copy of the getModuleVersions() method from ProcessWireUpgradeCheck module
    /**
     * Cached module versions data
     *
     * @param array
     *
     */
    protected $getModuleVersionsData = array();

    /**
     * Check all site modules for newer versions from the directory
     *
     * @param bool $onlyNew Only return array of modules with new versions available
     * @return array of array(
     *  'ModuleName' => array(
     *      'title' => 'Module Title',
     *      'local' => '1.2.3', // current installed version
     *      'remote' => '1.2.4', // directory version available, or boolean false if not found in directory
     *      'new' => true|false, // true if newer version available, false if not
     *      'requiresVersions' => array('ModuleName' => array('>', '1.2.3')), // module requirements
     *      )
     *  )
     *
     */
    public function getModuleVersions($onlyNew = false) {

        if(!$this->config->moduleServiceKey) throw new WireException("This feature requires ProcessWire 2.4.19+");

        $url =  $this->config->moduleServiceURL .
            "?apikey=" . $this->config->moduleServiceKey .
            "&limit=100" .
            "&field=module_version,version,requires_versions" .
            "&class_name=";

        $names = array();
        $versions = array();

        foreach($this->modules as $module) {
            $name = $module->className();
            $info = $this->modules->getModuleInfoVerbose($name);
            if($info['core']) continue;
            $names[] = $name;
            $versions[$name] = array(
                'title' => $info['title'],
                'local' => $this->modules->formatVersion($info['version']),
                'remote' => false,
                'new' => 0,
                'requiresVersions' => $info['requiresVersions']
                );
        }

        if(!count($names)) return array();
        $url .= implode(',', $names);

        $data = $this->getModuleVersionsData;
        if(empty($data)) {
            // if not cached
            $http = new WireHttp();
            $data = $http->getJSON($url);
            $this->getModuleVersionsData = $data;

            if(!is_array($data)) {
                $error = $http->getError();
                if(!$error) $error = $this->_('Error retrieving modules directory data');
                $this->error($error . " (" . $this->className() . ")");
                return array();
            }
        }

        foreach($data['items'] as $item) {
            $name = $item['class_name'];
            $versions[$name]['remote'] = $item['module_version'];
            $new = version_compare($versions[$name]['remote'], $versions[$name]['local']);
            $versions[$name]['new'] = $new;
                    if($new <= 0) {
                // local is up-to-date or newer than remote
                if($onlyNew) unset($versions[$name]);
            } else {
                // remote is newer than local
                $versions[$name]['requiresVersions'] = $item['requires_versions'];
            }
        }

        if($onlyNew) foreach($versions as $name => $data) {
            if($data['remote'] === false) unset($versions[$name]);
        }

        return $versions;
    }


    public function getInstallableModules() {
        $modules = $this->wire('modules');
        $installableModuleNames = array();
        $installableModuleNames = array_keys($modules->getInstallable());
        return $installableModuleNames;
    }

    public function createBackup() {

        $backupDir = $this->config->paths->assets.'moduletoolkitbackups/'.date('Y-m-d_H-i-s');

        if (!file_exists($this->config->paths->assets.'moduletoolkitbackups/')) mkdir($this->config->paths->assets.'moduletoolkitbackups/');
        if (!file_exists($backupDir)) mkdir($backupDir);

        $backup = new WireDatabaseBackup($backupDir.'/');
        $backup->setDatabase($this->database);
        $backup->setDatabaseConfig($this->config);

        $file = $backup->backup(array('filename' => 'moduletoolkitbackup.sql'));

        wireCopy($this->config->paths->siteModules, $backupDir . '/', true);
    }


    /**
     * Install the module and create the page where it lives
     *
     */
    public function ___install() {

        if(ProcessWire::versionMajor == 2 && ProcessWire::versionMinor < 4) {
            throw new WireException("This module requires ProcessWire 2.4 or newer");
        }

        $wp = $this->getInstalledPage();
        $this->message("Installed to {$wp->path}");
        if($wp->parent->name == 'setup') $this->message("Click to your 'Setup' page to start using Module Toolkit");
    }

    /**
     * Return the page that this Process is installed on
     *
     */
    protected function getInstalledPage() {

        $admin = $this->pages->get($this->config->adminRootPageID);
        $parent = $admin->child("name=setup");
        if(!$parent->id) $parent = $admin;
        $wp = $parent->child("name=" . self::adminPageName);

        if(!$wp->id) {
            $wp = new Page();
            $wp->parent = $parent;
            $wp->template = $this->templates->get('admin');
            $wp->name = self::adminPageName;
            $wp->title = "Module Toolkit";
            $wp->process = $this;
            $wp->sort = $parent->numChildren;
            $wp->save();
        }

        return $wp;
    }

    /**
     * Uninstall the module
     *
     */
    public function ___uninstall() {
        $wp = $this->getInstalledPage();
        if($wp->id) {
            $this->message("Removed {$wp->path}");
            $this->pages->delete($wp);
        }
    }

}
